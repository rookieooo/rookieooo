数组的高级操作：
	二分查找：数组里元素有序。查某个元素在数组里的索引位置
		1、定义查找范围，初始值、结束值
		2、求出查找范围内的中间位置，(初始值+结束值)/2	mid
		3、判断中间位置索引的元素 是否大于 要查找的元素
		4、如果大于：表示要查找元素在左边，将中间位置索引-1 赋值给 结束值
			如果小于：表示要查找元素在有边，将中间位置索引+1 赋值给 初始值
		5、循环判断初始值<=结束值	
	冒泡排序：给数组中的元素进行排序
		1、外层循环，控制要比较多少轮。每轮比较，都会将当前范围内的最大元素，放到最右边
		2、内层循环，循环比较当前元素和下一个元素的大小
		3、如果当前元素大，通过temp，将当前元素放到下一个元素的位置，所以当本轮比较结束后，
			最右边一定是本轮比较元素里最大的元素
		4、因为每轮比较都会确定一个元素的位置，所以每轮结束后，下一轮比较时都会将比较范围-1。
			所以内层循环 -i
		5、-1，因为当前元素和下一个元素比较，会出现arr[j+1],如果不-1,会出现索引越界
Arrays：toString(),sort()快速排序,binarySearch()
递归：方法自己调自己
		注意点：1、方法一定要有出口，否则栈内存溢出
			2、找到规律，将大规模问题，拆分成小规模问题
异常：Throwable
	1、Error错误
	2、异常
		(1)运行时异常，RunTimeException，编译通过，运行失败
		(2)编译时异常，非RunTimeException，编译失败
	处理异常两种方式：
		Throws，直接抛出异常，抛给调用者，如果没有调用者直接抛给JVM，
			(1)控制台红色打印异常信息	(2)停止程序
		try{}cache(){}，捕获异常，在cache代码块中判断是否出现了该异常，如果出现，在cache块中进行处理
			(1)通过Throws向调用者抛出异常，方法声明上
			(2)通过throw 手动new异常，在方法中
Date：时间类，中国计算机原点时间1970年1月1日08时0分0秒
	new Date()，获取当前电脑系统时间
	new Date(1000L)，在时间原点上加1000毫秒
	getTime(),获取当前Date对象的毫秒值
	setTime(1000L),修改当前Date对象的时间，在时间原点上加1000毫秒
SimpleDateFormat:格式化时间类
	format();Date --> String		yyyy-MM-dd HH-mm-ss
	parse();String --> Date










			